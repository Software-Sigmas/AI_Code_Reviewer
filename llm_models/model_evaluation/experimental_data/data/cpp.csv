id,name,explanation,code
1,Selection Sort,The algorithm repeatedly selects the smallest  or largest  element from the unsorted portion of the list and swaps it with the first element of the unsorted part. This process is repeated for the remaining unsorted portion until the entire list is sorted.,"// C++ program for implementation of
// selection sort
#include <bits/stdc++.h>
using namespace std;
// Function for Selection sort
void selectionSort(int arr[], int n)
{
int i, j, min_idx;
// One by one move boundary of
// unsorted subarray
for (i = 0; i < n - 1; i++) {
// Find the minimum element in
// unsorted array
min_idx = i;
for (j = i + 1; j < n; j++) {
if (arr[j] < arr[min_idx])
min_idx = j;
}
// Swap the found minimum element
// with the first element
if (min_idx != i)
swap(arr[min_idx], arr[i]);
}
}
// Function to print an array
void printArray(int arr[], int size)
{
int i;
for (i = 0; i < size; i++) {
cout << arr[i] << "" "";
cout << endl;
}
}
// Driver program
int main()
{
int arr[] = { 64, 25, 12, 22, 11 };
int n = sizeof(arr) / sizeof(arr[0]);
// Function Call
selectionSort(arr, n);
cout << ""Sorted array: \n"";
printArray(arr, n);
return 0;
}
// This is code is contributed by rathbhupendra"
2,Bubble Sort,Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. This algorithm is not suitable for large data sets as its average and worst case time complexity is quite high.,"// Optimized implementation of Bubble sort
#include <bits/stdc++.h>
using namespace std;
// An optimized version of Bubble Sort
void bubbleSort(int arr[], int n)
{
int i, j;
bool swapped;
for (i = 0; i < n - 1; i++) {
swapped = false;
for (j = 0; j < n - i - 1; j++) {
if (arr[j] > arr[j + 1]) {
swap(arr[j], arr[j + 1]);
swapped = true;
}
}
// If no two elements were swapped
// by inner loop, then break
if (swapped == false)
break;
}
}
// Function to print an array
void printArray(int arr[], int size)
{
int i;
for (i = 0; i < size; i++)
cout << "" "" << arr[i];
}
// Driver program to test above functions
int main()
{
int arr[] = { 64, 34, 25, 12, 22, 11, 90 };
int N = sizeof(arr) / sizeof(arr[0]);
bubbleSort(arr, N);
cout << ""Sorted array: \n"";
printArray(arr, N);
return 0;
}
// This code is contributed by shivanisinghss2110"
3,Insertion Sort,"To sort an array of size N in ascending order iterate over the array and compare the current element  key  to its predecessor, if the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.","// C++ program for insertion sort
#include <bits/stdc++.h>
using namespace std;
// Function to sort an array using
// insertion sort
void insertionSort(int arr[], int n)
{
int i, key, j;
for (i = 1; i < n; i++) {
key = arr[i];
j = i - 1;
// Move elements of arr[0..i-1],
// that are greater than key,
// to one position ahead of their
// current position
while (j >= 0 && arr[j] > key) {
arr[j + 1] = arr[j];
j = j - 1;
}
arr[j + 1] = key;
}
}
// A utility function to print an array
// of size n
void printArray(int arr[], int n)
{
int i;
for (i = 0; i < n; i++)
cout << arr[i] << "" "";
cout << endl;
}
// Driver code
int main()
{
int arr[] = { 12, 11, 13, 5, 6 };
int N = sizeof(arr) / sizeof(arr[0]);
insertionSort(arr, N);
printArray(arr, N);
return 0;
}
// This is code is contributed by rathbhupendra"
4,Merge Sort,"Merge sort is defined as a sorting algorithm that works by dividing an array into smaller subarrays, sorting each subarray, and then merging the sorted subarrays back together to form the final sorted array.","// C++ program for Merge Sort
#include <bits/stdc++.h>
using namespace std;
// Merges two subarrays of array[].
// First subarray is arr[begin..mid]
// Second subarray is arr[mid+1..end]
void merge(int array[], int const left, int const mid,
int const right)
{
int const subArrayOne = mid - left + 1;
int const subArrayTwo = right - mid;
// Create temp arrays
auto *leftArray = new int[subArrayOne],
*rightArray = new int[subArrayTwo];
// Copy data to temp arrays leftArray[] and rightArray[]
for (auto i = 0; i < subArrayOne; i++)
leftArray[i] = array[left + i];
for (auto j = 0; j < subArrayTwo; j++)
rightArray[j] = array[mid + 1 + j];
auto indexOfSubArrayOne = 0, indexOfSubArrayTwo = 0;
int indexOfMergedArray = left;
// Merge the temp arrays back into array[left..right]
while (indexOfSubArrayOne < subArrayOne
&& indexOfSubArrayTwo < subArrayTwo) {
if (leftArray[indexOfSubArrayOne]
<= rightArray[indexOfSubArrayTwo]) {
array[indexOfMergedArray]
= leftArray[indexOfSubArrayOne];
indexOfSubArrayOne++;
}
else {
array[indexOfMergedArray]
= rightArray[indexOfSubArrayTwo];
indexOfSubArrayTwo++;
}
indexOfMergedArray++;
}
// Copy the remaining elements of
// left[], if there are any
while (indexOfSubArrayOne < subArrayOne) {
array[indexOfMergedArray]
= leftArray[indexOfSubArrayOne];
indexOfSubArrayOne++;
indexOfMergedArray++;
}
// Copy the remaining elements of
// right[], if there are any
while (indexOfSubArrayTwo < subArrayTwo) {
array[indexOfMergedArray]
= rightArray[indexOfSubArrayTwo];
indexOfSubArrayTwo++;
indexOfMergedArray++;
}
delete[] leftArray;
delete[] rightArray;
}
// begin is for left index and end is right index
// of the sub-array of arr to be sorted
void mergeSort(int array[], int const begin, int const end)
{
if (begin >= end)
return;
int mid = begin + (end - begin) / 2;
mergeSort(array, begin, mid);
mergeSort(array, mid + 1, end);
merge(array, begin, mid, end);
}
// UTILITY FUNCTIONS
// Function to print an array
void printArray(int A[], int size)
{
for (int i = 0; i < size; i++)
cout << A[i] << "" "";
cout << endl;
}
// Driver code
int main()
{
int arr[] = { 12, 11, 13, 5, 6, 7 };
int arr_size = sizeof(arr) / sizeof(arr[0]);
cout << ""Given array is \n"";
printArray(arr, arr_size);
mergeSort(arr, 0, arr_size - 1);
cout << ""\nSorted array is \n"";
printArray(arr, arr_size);
return 0;
}
// This code is contributed by Mayank Tyagi
// This code was revised by Joshua Estes"
5,Quick Sort,QuickSort is a sorting algorithm based on the Divide and Conquer algorithm that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.,"#include <bits/stdc++.h>
using namespace std;
int partition(int arr[],int low,int high)
{
//choose the pivot
int pivot=arr[high];
//Index of smaller element and Indicate
//the right position of pivot found so far
int i=(low-1);
for(int j=low;j<=high;j++)
{
//If current element is smaller than the pivot
if(arr[j]<pivot)
{
//Increment index of smaller element
i++;
swap(arr[i],arr[j]);
}
}
swap(arr[i+1],arr[high]);
return (i+1);
}
// The Quicksort function Implement
void quickSort(int arr[],int low,int high)
{
// when low is less than high
if(low<high)
{
// pi is the partition return index of pivot
int pi=partition(arr,low,high);
//Recursion Call
//smaller element than pivot goes left and
//higher element goes right
quickSort(arr,low,pi-1);
quickSort(arr,pi+1,high);
}
}
int main() {
int arr[]={10,7,8,9,1,5};
int n=sizeof(arr)/sizeof(arr[0]);
// Function call
quickSort(arr,0,n-1);
//Print the sorted array
cout<<""Sorted Array\n"";
for(int i=0;i<n;i++)
{
cout<<arr[i]<<"" "";
}
return 0;
}
// This Code is Contributed By Diwakar Jha"
6,Heap Sort,Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements.,"// C++ program for implementation of Heap Sort
#include <iostream>
using namespace std;
// To heapify a subtree rooted with node i
// which is an index in arr[].
// n is size of heap
void heapify(int arr[], int N, int i)
{
// Initialize largest as root
int largest = i;
// left = 2i + 1
int l = 2 * i + 1;
// right = 2i + 2
int r = 2 * i + 2;
// If left child is larger than root
if (l < N && arr[l] > arr[largest])
largest = l;
// If right child is larger than largest
// so far
if (r < N && arr[r] > arr[largest])
largest = r;
// If largest is not root
if (largest != i) {
swap(arr[i], arr[largest]);
// Recursively heapify the affected
// sub-tree
heapify(arr, N, largest);
}
}
// Main function to do heap sort
void heapSort(int arr[], int N)
{
// Build heap (rearrange array)
for (int i = N / 2 - 1; i >= 0; i--)
heapify(arr, N, i);
// One by one extract an element
// from heap
for (int i = N - 1; i > 0; i--) {
// Move current root to end
swap(arr[0], arr[i]);
// call max heapify on the reduced heap
heapify(arr, i, 0);
}
}
// A utility function to print array of size n
void printArray(int arr[], int N)
{
for (int i = 0; i < N; ++i)
cout << arr[i] << "" "";
cout << ""\n"";
}
// Driver's code
int main()
{
int arr[] = { 12, 11, 13, 5, 6, 7 };
int N = sizeof(arr) / sizeof(arr[0]);
// Function call
heapSort(arr, N);
cout << ""Sorted array is \n"";
printArray(arr, N);
}"
7,Radix Sort,Radix Sort is a linear sorting algorithm that sorts elements by processing them digit by digit. It is an efficient sorting algorithm for integers or strings with fixed size keys.,"// C++ implementation of Radix Sort
#include <iostream>
using namespace std;
// A utility function to get maximum
// value in arr[]
int getMax(int arr[], int n)
{
int mx = arr[0];
for (int i = 1; i < n; i++)
if (arr[i] > mx)
mx = arr[i];
return mx;
}
// A function to do counting sort of arr[]
// according to the digit
// represented by exp.
void countSort(int arr[], int n, int exp)
{
// Output array
int output[n];
int i, count[10] = { 0 };
// Store count of occurrences
// in count[]
for (i = 0; i < n; i++)
count[(arr[i] / exp) % 10]++;
// Change count[i] so that count[i]
// now contains actual position
// of this digit in output[]
for (i = 1; i < 10; i++)
count[i] += count[i - 1];
// Build the output array
for (i = n - 1; i >= 0; i--) {
output[count[(arr[i] / exp) % 10] - 1] = arr[i];
count[(arr[i] / exp) % 10]--;
}
// Copy the output array to arr[],
// so that arr[] now contains sorted
// numbers according to current digit
for (i = 0; i < n; i++)
arr[i] = output[i];
}
// The main function to that sorts arr[]
// of size n using Radix Sort
void radixsort(int arr[], int n)
{
// Find the maximum number to
// know number of digits
int m = getMax(arr, n);
// Do counting sort for every digit.
// Note that instead of passing digit
// number, exp is passed. exp is 10^i
// where i is current digit number
for (int exp = 1; m / exp > 0; exp *= 10)
countSort(arr, n, exp);
}
// A utility function to print an array
void print(int arr[], int n)
{
for (int i = 0; i < n; i++)
cout << arr[i] << "" "";
}
// Driver Code
int main()
{
int arr[] = { 543, 986, 217, 765, 329 };
int n = sizeof(arr) / sizeof(arr[0]);
// Function Call
radixsort(arr, n);
print(arr, n);
return 0;
}"
8,Bucket Sort,"Bucket sort is a sorting technique that involves dividing elements into various groups, or buckets. These buckets are formed by uniformly distributing the elements. Once the elements are divided into buckets, they can be sorted using any other sorting algorithm. Finally, the sorted elements are gathered together in an ordered fashion.","// C++ program to sort an
// array using bucket sort
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
// Function to sort arr[] of
// size n using bucket sort
void bucketSort(float arr[], int n)
{
// 1) Create n empty buckets
vector<float> b[n];
// 2) Put array elements
// in different buckets
for (int i = 0; i < n; i++) {
// Index in bucket
int bi = n * arr[i];
b[bi].push_back(arr[i]);
}
// 3) Sort individual buckets
for (int i = 0; i < n; i++)
sort(b[i].begin(), b[i].end());
// 4) Concatenate all buckets into arr[]
int index = 0;
for (int i = 0; i < n; i++)
for (int j = 0; j < b[i].size(); j++)
arr[index++] = b[i][j];
}
// Driver program to test above function
int main()
{
float arr[]
= { 0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434 };
int n = sizeof(arr) / sizeof(arr[0]);
bucketSort(arr, n);
cout << ""Sorted array is \n"";
for (int i = 0; i < n; i++)
cout << arr[i] << "" "";
return 0;
}"
9,Bingo Sort,"This Sorting Technique is similar to the Selection Sort in which we first find the smallest element called Bingo Element, and then we repeatedly iterate the elements of the array to get the correct positions of all the elements. Similarly, find the next bingo element for the next pass, and so on. Every distinct element is considered a Bingo Element and called out in increasing order.","#include <iostream>
#include <vector>
using namespace std;
// Function for finding the maximum and minimum element of
// the Array
void maxMin(vector<int> vec, int n, int& bingo,
int& nextBingo)
{
for (int i = 1; i < n; bingo = min(bingo, vec[i]), nextBingo = max(nextBingo, vec[i]), i++)
;
}
// Function to sort the array
void bingoSort(vector<int>& vec, int n)
{
int bingo = vec[0];
int nextBingo = vec[0];
maxMin(vec, n, bingo, nextBingo);
int largestEle = nextBingo;
int nextElePos = 0;
while (bingo < nextBingo) {
// Will keep the track of the element position to
// shifted to their correct position
int startPos = nextElePos;
for (int i = startPos; i < n; i++) {
if (vec[i] == bingo) {
swap(vec[i], vec[nextElePos]);
nextElePos = nextElePos + 1;
}
// Here we are finding the next Bingo Element
// for the next pass
else if (vec[i] < nextBingo)
nextBingo = vec[i];
}
bingo = nextBingo;
nextBingo = largestEle;
}
}
// Function to print the array
void printArray(vector<int> arr, int n)
{
cout << ""Sorted Array: "";
for (int i = 0; i < n; i++) {
cout << arr[i] << "" "";
}
cout << endl;
}
// Driver Code
int main()
{
vector<int> arr = { 5, 4, 8, 5, 4, 8, 5, 4, 4, 4 };
bingoSort(arr, arr.size());
printArray(arr, arr.size());
vector<int> arr2 = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };
bingoSort(arr2, arr2.size());
printArray(arr2, arr2.size());
vector<int> arr3 = { 0, 1, 0, 1, 0, 1 };
bingoSort(arr3, arr3.size());
printArray(arr3, arr3.size());
return 0;
}"
10,Shell Sort,"Shell sort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange of far items. In Shell sort, we make the array h sorted for a large value of h. We keep reducing the value of h until it becomes 1. An array is said to be h sorted if all sublists of every h th element are sorted.","// C++ implementation of Shell Sort
#include <iostream>
using namespace std;
/* function to sort arr using shellSort */
int shellSort(int arr[], int n)
{
// Start with a big gap, then reduce the gap
for (int gap = n/2; gap > 0; gap /= 2)
{
// Do a gapped insertion sort for this gap size.
// The first gap elements a[0..gap-1] are already in gapped order
// keep adding one more element until the entire array is
// gap sorted
for (int i = gap; i < n; i += 1)
{
// add a[i] to the elements that have been gap sorted
// save a[i] in temp and make a hole at position i
int temp = arr[i];
// shift earlier gap-sorted elements up until the correct
// location for a[i] is found
int j;
for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)
arr[j] = arr[j - gap];
// put temp (the original a[i]) in its correct location
arr[j] = temp;
}
}
return 0;
}
void printArray(int arr[], int n)
{
for (int i=0; i<n; i++)
cout << arr[i] << "" "";
}
int main()
{
int arr[] = {12, 34, 54, 2, 3}, i;
int n = sizeof(arr)/sizeof(arr[0]);
cout << ""Array before sorting: \n"";
printArray(arr, n);
shellSort(arr, n);
cout << ""\nArray after sorting: \n"";
printArray(arr, n);
return 0;
}"
11,Tim Sort,Tim Sort is a hybrid sorting algorithm derived from merge sort and insertion sort. It was designed to perform well on many kinds of real world data. Tim Sort is the default sorting algorithm used by Python s sorted   and list.sort   functions.,"// C++ program to perform TimSort.
#include <bits/stdc++.h>
using namespace std;
const int RUN = 32;
// This function sorts array from left
// index to to right index which is
// of size atmost RUN
void insertionSort(int arr[], int left, int right)
{
for (int i = left + 1; i <= right; i++) {
int temp = arr[i];
int j = i - 1;
while (j >= left && arr[j] > temp) {
arr[j + 1] = arr[j];
j--;
}
arr[j + 1] = temp;
}
}
// Merge function merges the sorted runs
void merge(int arr[], int l, int m, int r)
{
// Original array is broken in two
// parts left and right array
int len1 = m - l + 1, len2 = r - m;
int left[len1], right[len2];
for (int i = 0; i < len1; i++)
left[i] = arr[l + i];
for (int i = 0; i < len2; i++)
right[i] = arr[m + 1 + i];
int i = 0;
int j = 0;
int k = l;
// After comparing, we
// merge those two array
// in larger sub array
while (i < len1 && j < len2) {
if (left[i] <= right[j]) {
arr[k] = left[i];
i++;
}
else {
arr[k] = right[j];
j++;
}
k++;
}
// Copy remaining elements of
// left, if any
while (i < len1) {
arr[k] = left[i];
k++;
i++;
}
// Copy remaining element of
// right, if any
while (j < len2) {
arr[k] = right[j];
k++;
j++;
}
}
// Iterative Timsort function to sort the
// array[0...n-1] (similar to merge sort)
void timSort(int arr[], int n)
{
// Sort individual subarrays of size RUN
for (int i = 0; i < n; i += RUN)
insertionSort(arr, i, min((i + RUN - 1), (n - 1)));
// Start merging from size RUN (or 32).
// It will merge
// to form size 64, then 128, 256
// and so on ....
for (int size = RUN; size < n; size = 2 * size) {
// pick starting point of
// left sub array. We
// are going to merge
// arr[left..left+size-1]
// and arr[left+size, left+2size-1]
// After every merge, we
// increase left by 2size
for (int left = 0; left < n; left += 2 * size) {
// Find ending point of
// left sub array
// mid+1 is starting point
// of right sub array
int mid = left + size - 1;
int right = min((left + 2 * size - 1), (n - 1));
// merge sub array arr[left.....mid] &
// arr[mid+1....right]
if (mid < right)
merge(arr, left, mid, right);
}
}
}
// Utility function to print the Array
void printArray(int arr[], int n)
{
for (int i = 0; i < n; i++)
printf(""%d "", arr[i]);
printf(""\n"");
}
// Driver program to test above function
int main()
{
int arr[] = { -2, 7, 15, -14, 0, 15, 0, 7,
-7, -4, -13, 5, 8, -14, 12 };
int n = sizeof(arr) / sizeof(arr[0]);
printf(""Given Array is\n"");
printArray(arr, n);
// Function Call
timSort(arr, n);
printf(""After Sorting Array is\n"");
printArray(arr, n);
return 0;
}"
12,Comb Sort,Comb Sort is mainly an improvement over Bubble Sort. Bubble sort always compares adjacent values. So all inversions are removed one by one. Comb Sort improves on Bubble Sort by using a gap of the size of more than 1. The gap starts with a large value and shrinks by a factor of 1.3 in every iteration until it reaches the value 1. Thus Comb Sort removes more than one inversion count with one swap and performs better than Bubble Sort.,"// C++ implementation of Comb Sort
#include<bits/stdc++.h>
using namespace std;
// To find gap between elements
int getNextGap(int gap)
{
// Shrink gap by Shrink factor
gap = (gap*10)/13;
if (gap < 1)
return 1;
return gap;
}
// Function to sort a[0..n-1] using Comb Sort
void combSort(int a[], int n)
{
// Initialize gap
int gap = n;
// Initialize swapped as true to make sure that
// loop runs
bool swapped = true;
// Keep running while gap is more than 1 and last
// iteration caused a swap
while (gap != 1 || swapped == true)
{
// Find next gap
gap = getNextGap(gap);
// Initialize swapped as false so that we can
// check if swap happened or not
swapped = false;
// Compare all elements with current gap
for (int i=0; i<n-gap; i++)
{
if (a[i] > a[i+gap])
{
swap(a[i], a[i+gap]);
swapped = true;
}
}
}
}
// Driver program
int main()
{
int a[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0};
int n = sizeof(a)/sizeof(a[0]);
combSort(a, n);
printf(""Sorted array: \n"");
for (int i=0; i<n; i++)
printf(""%d "", a[i]);
return 0;
}"
13,Pigeonhole Sort,Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists of elements where the number of elements and the number of possible key values are approximately the same.,"/* C++ program to implement Pigeonhole Sort /
#include <bits/stdc++.h>
using namespace std;
/ Sorts the array using pigeonhole algorithm */
void pigeonholeSort(int arr[], int n)
{
// Find minimum and maximum values in arr[]
int min = arr[0], max = arr[0];
for (int i = 1; i < n; i++)
{
if (arr[i] < min)
min = arr[i];
if (arr[i] > max)
max = arr[i];
}
int range = max - min + 1; // Find range
// Create an array of vectors. Size of array
// range. Each vector represents a hole that
// is going to contain matching elements.
vector<int> holes[range];
// Traverse through input array and put every
// element in its respective hole
for (int i = 0; i < n; i++)
holes[arr[i]-min].push_back(arr[i]);
// Traverse through all holes one by one. For
// every hole, take its elements and put in
// array.
int index = 0; // index in sorted array
for (int i = 0; i < range; i++)
{
vector<int>::iterator it;
for (it = holes[i].begin(); it != holes[i].end(); ++it)
arr[index++] = *it;
}
}
// Driver program to test the above function
int main()
{
int arr[] = {8, 3, 2, 7, 4, 6, 8};
int n = sizeof(arr)/sizeof(arr[0]);
pigeonholeSort(arr, n);
printf(""Sorted order is : "");
for (int i = 0; i < n; i++)
printf(""%d "", arr[i]);
return 0;
}"
14,Cycle Sort,"The basic idea behind cycle sort is to divide the input array into cycles, where each cycle consists of elements that belong to the same position in the sorted output array. The algorithm then performs a series of swaps to place each element in its correct position within its cycle, until all cycles are complete and the array is sorted.","// C++ program to implement cycle sort
#include <iostream>
using namespace std;
// Function sort the array using Cycle sort
void cycleSort(int arr[], int n)
{
// count number of memory writes
int writes = 0;
// traverse array elements and put it to on
// the right place
for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {
// initialize item as starting point
int item = arr[cycle_start];
// Find position where we put the item. We basically
// count all smaller elements on right side of item.
int pos = cycle_start;
for (int i = cycle_start + 1; i < n; i++)
if (arr[i] < item)
pos++;
// If item is already in correct position
if (pos == cycle_start)
continue;
// ignore all duplicate elements
while (item == arr[pos])
pos += 1;
// put the item to it's right position
if (pos != cycle_start) {
swap(item, arr[pos]);
writes++;
}
// Rotate rest of the cycle
while (pos != cycle_start) {
pos = cycle_start;
// Find position where we put the element
for (int i = cycle_start + 1; i < n; i++)
if (arr[i] < item)
pos += 1;
// ignore all duplicate elements
while (item == arr[pos])
pos += 1;
// put the item to it's right position
if (item != arr[pos]) {
swap(item, arr[pos]);
writes++;
}
}
}
// Number of memory writes or swaps
// cout << writes << endl ;
}
// Driver program to test above function
int main()
{
int arr[] = { 1, 8, 3, 9, 10, 10, 2, 4 };
int n = sizeof(arr) / sizeof(arr[0]);
cycleSort(arr, n);
cout << ""After sort : "" << endl;
for (int i = 0; i < n; i++)
cout << arr[i] << "" "";
return 0;
}"
15,Branch and Bound,Branch and bound is an algorithm design paradigm which is generally used for solving combinatorial optimization problems. These problems typically exponential in terms of time complexity and may require exploring all possible permutations in worst case. Branch and Bound solve these problems relatively quickly.,"// C++ program to solve knapsack problem using
// branch and bound
#include <bits/stdc++.h>
using namespace std;
// Structure for Item which store weight and corresponding
// value of Item
struct Item
{
float weight;
int value;
};
// Node structure to store information of decision
// tree
struct Node
{
// level --> Level of node in decision tree (or index
// in arr[]
// profit --> Profit of nodes on path from root to this
// node (including this node)
// bound ---> Upper bound of maximum profit in subtree
// of this node/
int level, profit, bound;
float weight;
};
// Comparison function to sort Item according to
// val/weight ratio
bool cmp(Item a, Item b)
{
double r1 = (double)a.value / a.weight;
double r2 = (double)b.value / b.weight;
return r1 > r2;
}
// Returns bound of profit in subtree rooted with u.
// This function mainly uses Greedy solution to find
// an upper bound on maximum profit.
int bound(Node u, int n, int W, Item arr[])
{
// if weight overcomes the knapsack capacity, return
// 0 as expected bound
if (u.weight >= W)
return 0;
// initialize bound on profit by current profit
int profit_bound = u.profit;
// start including items from index 1 more to current
// item index
int j = u.level + 1;
int totweight = u.weight;
// checking index condition and knapsack capacity
// condition
while ((j < n) && (totweight + arr[j].weight <= W))
{
totweight += arr[j].weight;
profit_bound += arr[j].value;
j++;
}
// If k is not n, include last item partially for
// upper bound on profit
if (j < n)
profit_bound += (W - totweight) * arr[j].value /
arr[j].weight;
return profit_bound;
}
// Returns maximum profit we can get with capacity W
int knapsack(int W, Item arr[], int n)
{
// sorting Item on basis of value per unit
// weight.
sort(arr, arr + n, cmp);
// make a queue for traversing the node
queue<Node> Q;
Node u, v;
// dummy node at starting
u.level = -1;
u.profit = u.weight = 0;
Q.push(u);
// One by one extract an item from decision tree
// compute profit of all children of extracted item
// and keep saving maxProfit
int maxProfit = 0;
while (!Q.empty())
{
// Dequeue a node
u = Q.front();
Q.pop();
// If it is starting node, assign level 0
if (u.level == -1)
v.level = 0;
// If there is nothing on next level
if (u.level == n-1)
continue;
// Else if not last node, then increment level,
// and compute profit of children nodes.
v.level = u.level + 1;
// Taking current level's item add current
// level's weight and value to node u's
// weight and value
v.weight = u.weight + arr[v.level].weight;
v.profit = u.profit + arr[v.level].value;
// If cumulated weight is less than W and
// profit is greater than previous profit,
// update maxprofit
if (v.weight <= W && v.profit > maxProfit)
maxProfit = v.profit;
// Get the upper bound on profit to decide
// whether to add v to Q or not.
v.bound = bound(v, n, W, arr);
// If bound value is greater than profit,
// then only push into queue for further
// consideration
if (v.bound > maxProfit)
Q.push(v);
// Do the same thing, but Without taking
// the item in knapsack
v.weight = u.weight;
v.profit = u.profit;
v.bound = bound(v, n, W, arr);
if (v.bound > maxProfit)
Q.push(v);
}
return maxProfit;
}
// driver program to test above function
int main()
{
int W = 10; // Weight of knapsack
Item arr[] = {{2, 40}, {3.14, 50}, {1.98, 100},
{5, 95}, {3, 30}};
int n = sizeof(arr) / sizeof(arr[0]);
cout << ""Maximum possible profit = ""
<< knapsack(W, arr, n);
return 0;
}"
16,Cocktail Sort,Cocktail Sort is a variation of Bubble sort. The Bubble sort algorithm always traverses elements from left and moves the largest element to its correct position in the first iteration and second largest in the second iteration and so on. Cocktail Sort traverses through a given array in both directions alternatively. Cocktail sort does not go through the unnecessary iteration making it efficient for large arrays.,"// C++ implementation of Cocktail Sort
#include <bits/stdc++.h>
using namespace std;
// Sorts array a[0..n-1] using Cocktail sort
void CocktailSort(int a[], int n)
{
bool swapped = true;
int start = 0;
int end = n - 1;
while (swapped) {
// reset the swapped flag on entering
// the loop, because it might be true from
// a previous iteration.
swapped = false;
// loop from left to right same as
// the bubble sort
for (int i = start; i < end; ++i) {
if (a[i] > a[i + 1]) {
swap(a[i], a[i + 1]);
swapped = true;
}
}
// if nothing moved, then array is sorted.
if (!swapped)
break;
// otherwise, reset the swapped flag so that it
// can be used in the next stage
swapped = false;
// move the end point back by one, because
// item at the end is in its rightful spot
--end;
// from right to left, doing the
// same comparison as in the previous stage
for (int i = end - 1; i >= start; --i) {
if (a[i] > a[i + 1]) {
swap(a[i], a[i + 1]);
swapped = true;
}
}
// increase the starting point, because
// the last stage would have moved the next
// smallest number to its rightful spot.
++start;
}
}
/* Prints the array */
void printArray(int a[], int n)
{
for (int i = 0; i < n; i++)
printf(""%d "", a[i]);
printf(""\n"");
}
// Driver code
int main()
{
int a[] = { 5, 1, 4, 2, 8, 0, 2 };
int n = sizeof(a) / sizeof(a[0]);
CocktailSort(a, n);
printf(""Sorted array :\n"");
printArray(a, n);
return 0;
}"
17,Strand Sort,Strand sort is a recursive sorting algorithm that sorts items of a list into increasing order. It has O n   worst time complexity which occurs when the input list is reverse sorted. It has a best case time complexity of O n  which occurs when the input is a list that is already sorted.,"// CPP program to implement Strand Sort
#include <bits/stdc++.h>
using namespace std;
// A recursive function to implement Strand
// sort.
// ip is input list of items (unsorted).
// op is output list of items (sorted)
void strandSort(list<int> &ip, list<int> &op)
{
// Base case : input is empty
if (ip.empty())
return;
// Create a sorted sublist with
// first item of input list as
// first item of the sublist
list<int> sublist;
sublist.push_back(ip.front());
ip.pop_front();
// Traverse remaining items of ip list
for (auto it = ip.begin(); it != ip.end(); ) {
// If current item of input list
// is greater than last added item
// to sublist, move current item
// to sublist as sorted order is
// maintained.
if (*it > sublist.back()) {
sublist.push_back(*it);
// erase() on list removes an
// item and returns iterator to
// next of removed item.
it = ip.erase(it);
}
// Otherwise ignore current element
else
it++;
}
// Merge current sublist into output
op.merge(sublist);
// Recur for remaining items in
// input and current items in op.
strandSort(ip, op);
}
// Driver code
int main(void)
{
list<int> ip{10, 5, 30, 40, 2, 4, 9};
// To store sorted output list
list<int> op;
// Sorting the list
strandSort(ip, op);
// Printing the sorted list
for (auto x : op)
cout << x << "" "";
return 0;
}
"
18,Bitonic Sort,"Bitonic Sort is a classic parallel algorithm for sorting.    The number of comparisons done by Bitonic sort is more than popular sorting algorithms like Merge Sort   does O log N  comparisons , but Bitonic sort is better for parallel implementation because we always compare elements in a predefined sequence and the sequence of comparison doesn t depend on data. Therefore it is suitable for implementation in hardware and parallel processor array.   Bitonic Sort can only be done if the number of elements to sort is 2 n. The procedure of bitonic sequence fails if the number of elements is not in the aforementioned quantity precisely.","/* C++ Program for Bitonic Sort. Note that this program
works only when size of input is a power of 2. /
#include<bits/stdc++.h>
using namespace std;
/The parameter dir indicates the sorting direction, ASCENDING
or DESCENDING; if (a[i] > a[j]) agrees with the direction,
then a[i] and a[j] are interchanged./
void compAndSwap(int a[], int i, int j, int dir)
{
if (dir==(a[i]>a[j]))
swap(a[i],a[j]);
}
/It recursively sorts a bitonic sequence in ascending order,
if dir = 1, and in descending order otherwise (means dir=0).
The sequence to be sorted starts at index position low,
the parameter cnt is the number of elements to be sorted./
void bitonicMerge(int a[], int low, int cnt, int dir)
{
if (cnt>1)
{
int k = cnt/2;
for (int i=low; i<low+k; i++)
compAndSwap(a, i, i+k, dir);
bitonicMerge(a, low, k, dir);
bitonicMerge(a, low+k, k, dir);
}
}
/ This function first produces a bitonic sequence by recursively
sorting its two halves in opposite sorting orders, and then
calls bitonicMerge to make them in the same order /
void bitonicSort(int a[],int low, int cnt, int dir)
{
if (cnt>1)
{
int k = cnt/2;
// sort in ascending order since dir here is 1
bitonicSort(a, low, k, 1);
// sort in descending order since dir here is 0
bitonicSort(a, low+k, k, 0);
// Will merge whole sequence in ascending order
// since dir=1.
bitonicMerge(a,low, cnt, dir);
}
}
/ Caller of bitonicSort for sorting the entire array of
length N in ASCENDING order */
void sort(int a[], int N, int up)
{
bitonicSort(a,0, N, up);
}
// Driver code
int main()
{
int a[]= {3, 7, 4, 8, 6, 2, 1, 5};
int N = sizeof(a)/sizeof(a[0]);
int up = 1; // means sort in ascending order
sort(a, N, up);
printf(""Sorted array: \n"");
for (int i=0; i<N; i++)
printf(""%d "", a[i]);
return 0;
}"
19,Pancake Sorting,"Following are the detailed steps. Let given array be arr   and size of array be n.    Start from current size equal to n and reduce current size by one while it s greater than 1. Let the current size be curr size.    Do following for every curr size       Find index of the maximum element in arr 0 to curr szie 1 . Let the index be  mi        Call flip arr, mi        Call flip arr, curr size   1 ","// C++ program to
// sort array using
// pancake sort
#include<bits/stdc++.h>
using namespace std;
/* Reverses arr[0..i] */
void flip(int arr[], int i)
{
int temp, start = 0;
while (start < i)
{
temp = arr[start];
arr[start] = arr[i];
arr[i] = temp;
start++;
i--;
}
}
// Returns index of the
// maximum element in
// arr[0..n-1]
int findMax(int arr[], int n)
{
int mi, i;
for (mi = 0, i = 0; i < n; ++i)
if (arr[i] > arr[mi])
mi = i;
return mi;
}
// The main function that
// sorts given array using
// flip operations
void pancakeSort(int *arr, int n)
{
// Start from the complete
// array and one by one
// reduce current size
// by one
for (int curr_size = n; curr_size > 1;
--curr_size)
{
// Find index of the
// maximum element in
// arr[0..curr_size-1]
int mi = findMax(arr, curr_size);
// Move the maximum
// element to end of
// current array if
// it's not already
// at the end
if (mi != curr_size-1)
{
// To move at the end,
// first move maximum
// number to beginning
flip(arr, mi);
// Now move the maximum
// number to end by
// reversing current array
flip(arr, curr_size-1);
}
}
}
// A utility function to print
// n array of size n
void printArray(int arr[], int n)
{
for (int i = 0; i < n; ++i)
cout<< arr[i]<<"" "";
}
// Driver program to test above function
int main()
{
int arr[] = {23, 10, 20, 11, 12, 6, 7};
int n = sizeof(arr)/sizeof(arr[0]);
pancakeSort(arr, n);
cout<<""Sorted Array ""<<endl;
printArray(arr, n);
return 0;
}
//This code is contributed by rathbhupendra"
20,BogoSort,"BogoSort also known as permutation sort, stupid sort, slow sort, shotgun sort or monkey sort is a particularly ineffective algorithm one person can ever imagine. It is based on generate and test paradigm. The algorithm successively generates permutations of its input until it finds one that is sorted. Wiki  For example, if bogosort is used to sort a deck of cards, it would consist of checking if the deck were in order, and if it were not, one would throw the deck into the air, pick the cards up at random, and repeat the process until the deck is sorted.","// C++ implementation of Bogo Sort
#include <bits/stdc++.h>
using namespace std;
// To check if array is sorted or not
bool isSorted(int a[], int n)
{
while (--n > 0)
if (a[n] < a[n - 1])
return false;
return true;
}
// To generate permutation of the array
void shuffle(int a[], int n)
{
for (int i = 0; i < n; i++)
swap(a[i], a[rand() % n]);
}
// Sorts array a[0..n-1] using Bogo sort
void bogosort(int a[], int n)
{
// if array is not sorted then shuffle
// the array again
while (!isSorted(a, n))
shuffle(a, n);
}
// prints the array
void printArray(int a[], int n)
{
for (int i = 0; i < n; i++)
cout << a[i] << "" "";
cout << ""\n"";
}
// Driver code
int main()
{
int a[] = { 3, 2, 5, 1, 0, 4 };
int n = sizeof a / sizeof a[0];
bogosort(a, n);
printf(""Sorted array :\n"");
printArray(a, n);
return 0;
}"
21,Gnome Sort,"Gnome Sort also called Stupid sort is based on the concept of a Garden Gnome sorting his flower pots. A garden gnome sorts the flower pots by the following method      He looks at the flower pot next to him and the previous one  if they are in the right order he steps one pot forward, otherwise he swaps them and steps one pot backwards.   If there is no previous pot  he is at the starting of the pot line , he steps forwards  if there is no pot next to him  he is at the end of the pot line , he is done.","// A C++ Program to implement Gnome Sort
#include <iostream>
using namespace std;
// A function to sort the algorithm using gnome sort
void gnomeSort(int arr[], int n)
{
int index = 0;
while (index < n) {
if (index == 0)
index++;
if (arr[index] >= arr[index - 1])
index++;
else {
swap(arr[index], arr[index - 1]);
index--;
}
}
return;
}
// A utility function ot print an array of size n
void printArray(int arr[], int n)
{
cout << ""Sorted sequence after Gnome sort: "";
for (int i = 0; i < n; i++)
cout << arr[i] << "" "";
cout << ""\n"";
}
// Driver program to test above functions.
int main()
{
int arr[] = { 34, 2, 10, -9 };
int n = sizeof(arr) / sizeof(arr[0]);
gnomeSort(arr, n);
printArray(arr, n);
return (0);
}"
22,Sleep Sort,"In this algorithm we create different threads for each of the elements in the input array and then each thread sleeps for an amount of time which is proportional to the value of corresponding array element. Hence, the thread having the least amount of sleeping time wakes up first and the number gets printed and then the second least element and so on. The largest element wakes up after a long time and then the element gets printed at the last. Thus the output is a sorted one. All this multithreading process happens in background and at the core of the OS. We do not get to know anything about what s happening in the background, hence this is a  mysterious  sorting algorithm.","// C implementation of Sleep Sort
#include <stdio.h>
#include <windows.h>
#include <process.h>
// This is the instruction set of a thread
// So in these threads, we ""sleep"" for a particular
// amount of time and then when it wakes up
// the number is printed out
void routine(void *a)
{
int n = *(int ) a; // typecasting from void to int
// Sleeping time is proportional to the number
// More precisely this thread sleep for 'n' milliseconds
Sleep(n);
// After the sleep, print the number
printf(""%d "", n);
}
/ A function that performs sleep sort
_beginthread() is a C run-time library call that creates a new
'thread' for all the integers in the array and returns that
thread.
Each of the 'thread' sleeps for a time proportional to that
integer and print it after waking.
We pass three parameters to _beginthread :-
1) start_address --> start address of the routine/function
which creates a new thread
2) stack_size --> Stack Size of the new thread (which is 0)
3) arglist --> Address of the argument to be passed
The return value of _beginthread() function is a handle to the
thread which is created. So we must accept is using the datatype-
'HANDLE' which is included in windows.h header
'HANDLE' datatype is used to represent an event/thread/process etc
So 'HANDLE' datatype is used to define a thread
We store the threads in an array - threads[] which is declared
using 'HANDLE' datatype.
WaitForMultipleObjects() is a function that processes the threads
and has four arguments-
1) no_of_threads --> Number of threads to be processed
2) array_of_threads --> This is the array of threads which should be
processed. This array must be of the type
'HANDLE'
3) TRUE or FALSE --> We pass TRUE if we want all the threads in the
array to be processed
4) time_limit --> The threads will be processed until this time limit
is crossed. So if we pass a 0 then no threads will
be processed, otherwise if we pass an INFINITE, then
the program will stop only when all the threads
are processed. We can put a cap on the execution
time of the program by passing the desired time
limit */
void sleepSort(int arr[], int n)
{
// An array of threads, one for each of the elements
// in the input array
HANDLE threads[n];
// Create the threads for each of the input array elements
for (int i = 0; i < n; i++)
threads[i] = (HANDLE)_beginthread(&routine, 0, &arr[i]);
// Process these threads
WaitForMultipleObjects(n, threads, TRUE, INFINITE);
return;
}
// Driver program to test above functions
int main()
{
// Doesn't work for negative numbers
int arr[] = {34, 23, 122, 9};
int n = sizeof(arr) / sizeof(arr[0]);
sleepSort (arr, n);
return(0);
}"
23,Stooge Sort,"Stooge Sort is a recursive sorting algorithm. It is not much efficient but interesting sorting algorithm. It generally divides the array into two overlapping parts  2 3 each . After that it performs sorting in first 2 3 part and then it performs sorting in last 2 3 part. And then, sorting is done on first 2 3 part to ensure that the array is sorted.","// C++ code to implement stooge sort
#include <iostream>
using namespace std;
// Function to implement stooge sort
void stoogesort(int arr[], int l, int h)
{
if (l >= h)
return;
// If first element is smaller than last,
// swap them
if (arr[l] > arr[h])
swap(arr[l], arr[h]);
// If there are more than 2 elements in
// the array
if (h - l + 1 > 2) {
int t = (h - l + 1) / 3;
// Recursively sort first 2/3 elements
stoogesort(arr, l, h - t);
// Recursively sort last 2/3 elements
stoogesort(arr, l + t, h);
// Recursively sort first 2/3 elements
// again to confirm
stoogesort(arr, l, h - t);
}
}
// Driver Code
int main()
{
int arr[] = { 2, 4, 5, 3, 1 };
int n = sizeof(arr) / sizeof(arr[0]);
// Calling Stooge Sort function to sort
// the array
stoogesort(arr, 0, n - 1);
// Display the sorted array
for (int i = 0; i < n; i++)
cout << arr[i] << "" "";
return 0;
}"
24,Tag Sort,"When we are operating on large array of objects, it might be too costly to swap these large object. After all its about the disk swaps and we want to minimize it!   Tag Sort allows sorting an integer array after tagging it with original object.   In turn, we only swap the tag array integers instead of large array of objects.   The actual elements are not being changed during the sort process. The positions in the tag array are being changed so they will hold the correct ordering of the elements when they are sorted.","#include <iostream>
#include <vector>
class Person {
private:
int id;
float salary;
int someBigObject;
public:
Person(int id, float salary)
: id(id), salary(salary), someBigObject(0) {}
float getSalary() {
return salary;
}
// The toString method in C++ can be replaced with the friend ostream operator overloading.
friend std::ostream& operator<<(std::ostream& os, const Person& person) {
os << ""Person{"" << ""id="" << http://person.id/ << "", salary="" << person.salary << "", someBigObject="" << person.someBigObject << ""}"";
return os;
}
};
void tagSort(std::vector<Person>& persons, std::vector<int>& tag) {
int n = persons.size();
for (int i = 0; i < n; i++) {
for (int j = i + 1; j < n; j++) {
if (persons[tag[i]].getSalary() > persons[tag[j]].getSalary()) {
// Note that we are not sorting the actual Persons array, but only the tag array
int temp = tag[i];
tag[i] = tag[j];
tag[j] = temp;
}
}
}
}
int main() {
// Creating objects and their original order (in tag vector)
int n = 5;
std::vector<Person> persons;
persons.push_back(Person(0, 233.5f));
persons.push_back(Person(1, 23.0f));
persons.push_back(Person(2, 13.98f));
persons.push_back(Person(3, 143.2f));
persons.push_back(Person(4, 3.0f));
std::vector<int> tag(n);
for (int i = 0; i < n; i++) {
tag[i] = i;
}
// Every Person object is tagged to an element in the tag vector.
std::cout << ""Given Person and Tag "" << std::endl;
for (int i = 0; i < n; i++) {
std::cout << persons[i] << "" : Tag: "" << tag[i] << std::endl;
}
// Modifying the tag vector so that we can access persons in sorted order.
tagSort(persons, tag);
std::cout << ""New Tag Array after getting sorted as per Person[]"" << std::endl;
for (int i = 0; i < n; i++) {
std::cout << tag[i] << std::endl;
}
// Accessing persons in sorted (by salary) way using the modified tag vector.
for (int i = 0; i < n; i++) {
std::cout << persons[tag[i]] << std::endl;
}
return 0;
}"
25,Tree Sort,Tree sort is a sorting algorithm that is based on Binary Search Tree data structure. It first creates a binary search tree from the elements of the input list or array and then performs an in order traversal on the created binary search tree to get the elements in sorted order.,"// C++ program to implement Tree Sort
#include<bits/stdc++.h>
using namespace std;
struct Node
{
int key;
struct Node *left, *right;
};
// A utility function to create a new BST Node
struct Node newNode(int item)
{
struct Node temp = new Node;
temp->key = item;
temp->left = temp->right = NULL;
return temp;
}
// Stores inorder traversal of the BST
// in arr[]
void storeSorted(Node root, int arr[], int &i)
{
if (root != NULL)
{
storeSorted(root->left, arr, i);
arr[i++] = root->key;
storeSorted(root->right, arr, i);
}
}
/ A utility function to insert a new
Node with given key in BST /
Node insert(Node node, int key)
{
/ If the tree is empty, return a new Node /
if (node == NULL) return newNode(key);
/ Otherwise, recur down the tree /
if (key < node->key)
node->left = insert(node->left, key);
else if (key > node->key)
node->right = insert(node->right, key);
/ return the (unchanged) Node pointer */
return node;
}
// This function sorts arr[0..n-1] using Tree Sort
void treeSort(int arr[], int n)
{
struct Node *root = NULL;
// Construct the BST
root = insert(root, arr[0]);
for (int i=1; i<n; i++)
root = insert(root, arr[i]);
// Store inorder traversal of the BST
// in arr[]
int i = 0;
storeSorted(root, arr, i);
}
// Driver Program to test above functions
int main()
{
//create input array
int arr[] = {5, 4, 7, 2, 11};
int n = sizeof(arr)/sizeof(arr[0]);
treeSort(arr, n);
for (int i=0; i<n; i++)
cout << arr[i] << "" "";
return 0;
}"
26,Dijkstra,"The idea is to generate a SPT  shortest path tree  with a given source as a root. Maintain an Adjacency Matrix with two sets, one set contains vertices included in the shortest path tree, other set includes vertices not yet included in the shortest path tree.  At every step of the algorithm, find a vertex that is in the other set  set not yet included  and has a minimum distance from the source.","// C++ program for Dijkstra's single source shortest path
// algorithm. The program is for adjacency matrix
// representation of the graph
#include <iostream>
using namespace std;
#include <limits.h>
// Number of vertices in the graph
#define V 9
// A utility function to find the vertex with minimum
// distance value, from the set of vertices not yet included
// in shortest path tree
int minDistance(int dist[], bool sptSet[])
{
// Initialize min value
int min = INT_MAX, min_index;
for (int v = 0; v < V; v++)
if (sptSet[v] == false && dist[v] <= min)
min = dist[v], min_index = v;
return min_index;
}
// A utility function to print the constructed distance
// array
void printSolution(int dist[])
{
cout << ""Vertex \t Distance from Source"" << endl;
for (int i = 0; i < V; i++)
cout << i << "" \t\t\t\t"" << dist[i] << endl;
}
// Function that implements Dijkstra's single source
// shortest path algorithm for a graph represented using
// adjacency matrix representation
void dijkstra(int graph[V][V], int src)
{
int dist[V]; // The output array. dist[i] will hold the
// shortest
// distance from src to i
bool sptSet[V]; // sptSet[i] will be true if vertex i is
// included in shortest
// path tree or shortest distance from src to i is
// finalized
// Initialize all distances as INFINITE and stpSet[] as
// false
for (int i = 0; i < V; i++)
dist[i] = INT_MAX, sptSet[i] = false;
// Distance of source vertex from itself is always 0
dist[src] = 0;
// Find shortest path for all vertices
for (int count = 0; count < V - 1; count++) {
// Pick the minimum distance vertex from the set of
// vertices not yet processed. u is always equal to
// src in the first iteration.
int u = minDistance(dist, sptSet);
// Mark the picked vertex as processed
sptSet[u] = true;
// Update dist value of the adjacent vertices of the
// picked vertex.
for (int v = 0; v < V; v++)
// Update dist[v] only if is not in sptSet,
// there is an edge from u to v, and total
// weight of path from src to v through u is
// smaller than current value of dist[v]
if (!sptSet[v] && graph[u][v]
&& dist[u] != INT_MAX
&& dist[u] + graph[u][v] < dist[v])
dist[v] = dist[u] + graph[u][v];
}
// print the constructed distance array
printSolution(dist);
}
// driver's code
int main()
{
/* Let us create the example graph discussed above */
int graph[V][V] = { { 0, 4, 0, 0, 0, 0, 0, 8, 0 },
{ 4, 0, 8, 0, 0, 0, 0, 11, 0 },
{ 0, 8, 0, 7, 0, 4, 0, 0, 2 },
{ 0, 0, 7, 0, 9, 14, 0, 0, 0 },
{ 0, 0, 0, 9, 0, 10, 0, 0, 0 },
{ 0, 0, 4, 14, 10, 0, 2, 0, 0 },
{ 0, 0, 0, 0, 0, 2, 0, 1, 6 },
{ 8, 11, 0, 0, 0, 0, 1, 0, 7 },
{ 0, 0, 2, 0, 0, 0, 6, 7, 0 } };
// Function call
dijkstra(graph, 0);
return 0;
}
// This code is contributed by shivanisinghss2110
"
27,Bellman-Ford,"Imagine you have a map with different cities connected by roads, each road having a certain distance. The Bellman Ford algorithm is like a guide that helps you find the shortest path from one city to all other cities, even if some roads have negative lengths. It s like a GPS for computers, useful for figuring out the quickest way to get from one point to another in a network. In this article, we ll take a closer look at how this algorithm works and why it s so handy in solving everyday problems.","// A C++ program for Bellman-Ford's single source
// shortest path algorithm.
#include <bits/stdc++.h>
using namespace std;
// a structure to represent a weighted edge in graph
struct Edge {
int src, dest, weight;
};
// a structure to represent a connected, directed and
// weighted graph
struct Graph {
// V-> Number of vertices, E-> Number of edges
int V, E;
// graph is represented as an array of edges.
struct Edge* edge;
};
// Creates a graph with V vertices and E edges
struct Graph* createGraph(int V, int E)
{
struct Graph* graph = new Graph;
graph->V = V;
graph->E = E;
graph->edge = new Edge[E];
return graph;
}
// A utility function used to print the solution
void printArr(int dist[], int n)
{
printf(""Vertex Distance from Source\n"");
for (int i = 0; i < n; ++i)
printf(""%d \t\t %d\n"", i, dist[i]);
}
// The main function that finds shortest distances from src
// to all other vertices using Bellman-Ford algorithm. The
// function also detects negative weight cycle
void BellmanFord(struct Graph* graph, int src)
{
int V = graph->V;
int E = graph->E;
int dist[V];
// Step 1: Initialize distances from src to all other
// vertices as INFINITE
for (int i = 0; i < V; i++)
dist[i] = INT_MAX;
dist[src] = 0;
// Step 2: Relax all edges |V| - 1 times. A simple
// shortest path from src to any other vertex can have
// at-most |V| - 1 edges
for (int i = 1; i <= V - 1; i++) {
for (int j = 0; j < E; j++) {
int u = graph->edge[j].src;
int v = graph->edge[j].dest;
int weight = graph->edge[j].weight;
if (dist[u] != INT_MAX
&& dist[u] + weight < dist[v])
dist[v] = dist[u] + weight;
}
}
// Step 3: check for negative-weight cycles. The above
// step guarantees shortest distances if graph doesn't
// contain negative weight cycle. If we get a shorter
// path, then there is a cycle.
for (int i = 0; i < E; i++) {
int u = graph->edge[i].src;
int v = graph->edge[i].dest;
int weight = graph->edge[i].weight;
if (dist[u] != INT_MAX
&& dist[u] + weight < dist[v]) {
printf(""Graph contains negative weight cycle"");
return; // If negative cycle is detected, simply
// return
}
}
printArr(dist, V);
return;
}
// Driver's code
int main()
{
/* Let us create the graph given in above example /
int V = 5; // Number of vertices in graph
int E = 8; // Number of edges in graph
struct Graph graph = createGraph(V, E);
// add edge 0-1 (or A-B in above figure)
graph->edge[0].src = 0;
graph->edge[0].dest = 1;
graph->edge[0].weight = -1;
// add edge 0-2 (or A-C in above figure)
graph->edge[1].src = 0;
graph->edge[1].dest = 2;
graph->edge[1].weight = 4;
// add edge 1-2 (or B-C in above figure)
graph->edge[2].src = 1;
graph->edge[2].dest = 2;
graph->edge[2].weight = 3;
// add edge 1-3 (or B-D in above figure)
graph->edge[3].src = 1;
graph->edge[3].dest = 3;
graph->edge[3].weight = 2;
// add edge 1-4 (or B-E in above figure)
graph->edge[4].src = 1;
graph->edge[4].dest = 4;
graph->edge[4].weight = 2;
// add edge 3-2 (or D-C in above figure)
graph->edge[5].src = 3;
graph->edge[5].dest = 2;
graph->edge[5].weight = 5;
// add edge 3-1 (or D-B in above figure)
graph->edge[6].src = 3;
graph->edge[6].dest = 1;
graph->edge[6].weight = 1;
// add edge 4-3 (or E-D in above figure)
graph->edge[7].src = 4;
graph->edge[7].dest = 3;
graph->edge[7].weight = -3;
// Function call
BellmanFord(graph, 0);
return 0;
}
"
28,Floyd Warshall,Suppose we have a graph G     with V vertices from 1 to N. Now we have to evaluate a shortestPathMatrix     where shortestPathMatrix i  j  represents the shortest path between vertices i and j. Obviously the shortest path between i to j will have some k number of intermediate nodes. The idea behind floyd warshall algorithm is to treat each and every vertex from 1 to N as an intermediate node one by one.,"// C++ Program for Floyd Warshall Algorithm
#include <bits/stdc++.h>
using namespace std;
// Number of vertices in the graph
#define V 4
/* Define Infinite as a large enough
value.This value will be used for
vertices not connected to each other /
#define INF 99999
// A function to print the solution matrix
void printSolution(int dist[][V]);
// Solves the all-pairs shortest path
// problem using Floyd Warshall algorithm
void floydWarshall(int dist[][V])
{
int i, j, k;
/ Add all vertices one by one to
the set of intermediate vertices.
---> Before start of an iteration,
we have shortest distances between all
pairs of vertices such that the
shortest distances consider only the
vertices in set {0, 1, 2, .. k-1} as
intermediate vertices.
----> After the end of an iteration,
vertex no. k is added to the set of
intermediate vertices and the set becomes {0, 1, 2, ..
k} /
for (k = 0; k < V; k++) {
// Pick all vertices as source one by one
for (i = 0; i < V; i++) {
// Pick all vertices as destination for the
// above picked source
for (j = 0; j < V; j++) {
// If vertex k is on the shortest path from
// i to j, then update the value of
// dist[i][j]
if (dist[i][j] > (dist[i][k] + dist[k][j])
&& (dist[k][j] != INF
&& dist[i][k] != INF))
dist[i][j] = dist[i][k] + dist[k][j];
}
}
}
// Print the shortest distance matrix
printSolution(dist);
}
/ A utility function to print solution /
void printSolution(int dist[][V])
{
cout << ""The following matrix shows the shortest ""
""distances""
"" between every pair of vertices \n"";
for (int i = 0; i < V; i++) {
for (int j = 0; j < V; j++) {
if (dist[i][j] == INF)
cout << ""INF""
<< "" "";
else
cout << dist[i][j] << "" "";
}
cout << endl;
}
}
// Driver's code
int main()
{
/ Let us create the following weighted graph
10
(0)------->(3)
| /|\
5 | |
| | 1
\|/ |
(1)------->(2)
3 */
int graph[V][V] = { { 0, 5, INF, 10 },
{ INF, 0, 3, INF },
{ INF, INF, 0, 1 },
{ INF, INF, INF, 0 } };
// Function call
floydWarshall(graph);
return 0;
}
// This code is contributed by Mythri J L"
29,Johnson,"Algorithm   1. Let the given graph be G. Add a new vertex s to the graph, add edges from the new vertex to all vertices of G. Let the modified graph be G . Run the Bellman Ford algorithm on G  with s as the source. Let the distances calculated by Bellman Ford be h 0 , h 1 , .. h V 1 . If we find a negative weight cycle, then return. Note that the negative weight cycle cannot be created by new vertex s as there is no edge to s. All edges are from s. Reweight the edges of the original graph. For each edge  u, v , assign the new weight as  original weight   h u    h v  . Remove the added vertex s and run Dijkstra s algorithm for every vertex.","#include <bits/stdc++.h>
#define INF 99999
using namespace std;
// Number of vertices in the graph
#define V 4
// A utility function to find the vertex with minimum
// distance value, from the set of vertices not yet included
// in shortest path tree
int minDistance(int dist[], bool sptSet[])
{
// Initialize min value
int min = INT_MAX, min_index;
for (int v = 0; v < V; v++)
if (sptSet[v] == false && dist[v] <= min)
min = dist[v], min_index = v;
return min_index;
}
// A utility function to print the constructed distance
// array
void printSolution(int dist[][V])
{
printf(""Following matrix shows the shortest distances""
"" between every pair of vertices \n"");
for (int i = 0; i < V; i++) {
for (int j = 0; j < V; j++) {
if (dist[i][j] == INF)
printf(""%7s"", ""INF"");
else
printf(""%7d"", dist[i][j]);
}
printf(""\n"");
}
}
// Solves the all-pairs shortest path problem using
// Johnson's algorithm
void floydWarshall(int graph[][V])
{
int dist[V][V], i, j, k;
/* Initialize the solution matrix same as input graph
matrix. Or we can say the initial values of shortest
distances are based
on shortest paths considering no intermediate vertex.
/
for (i = 0; i < V; i++)
for (j = 0; j < V; j++)
dist[i][j] = graph[i][j];
/ Add all vertices one by one to the set of
intermediate vertices.
---> Before start of a iteration, we have shortest
distances between all pairs of vertices such that the
shortest distances consider only the vertices in set
{0, 1, 2, .. k-1} as intermediate vertices.
----> After the end of a iteration, vertex no. k is
added to the set of
intermediate vertices and the set becomes {0, 1, 2, ..
k} /
for (k = 0; k < V; k++) {
// Pick all vertices as source one by one
for (i = 0; i < V; i++) {
// Pick all vertices as destination for the
// above picked source
for (j = 0; j < V; j++) {
// If vertex k is on the shortest path from
// i to j, then update the value of
// dist[i][j]
if (dist[i][k] + dist[k][j] < dist[i][j])
dist[i][j] = dist[i][k] + dist[k][j];
}
}
}
// Print the shortest distance matrix
printSolution(dist);
}
// driver program to test above function
int main()
{
/ Let us create the following weighted graph
10
(0)------->(3)
| /|\
5 | |
| | 1
\|/ |
(1)------->(2)
3 */
int graph[V][V] = { { 0, 5, INF, 10 },
{ INF, 0, 3, INF },
{ INF, INF, 0, 1 },
{ INF, INF, INF, 0 } };
// Print the solution
floydWarshall(graph);
return 0;
}"
30,Shortest Path in Directed Acyclic Graph,"Following is complete algorithm for finding shortest distances.  1. Initialize dist      INF, INF,  .  and dist s    0 where s is the source vertex. Create a topological order of all vertices. Do following for every vertex u in topological order.    ..Do following for every adjacent vertex v of u       if  dist v    dist u    weight u, v            dist v    dist u    weight u, v ","// C++ program to find single source shortest
// paths for Directed Acyclic Graphs
#include<iostream>
#include <bits/stdc++.h>
#define INF INT_MAX
using namespace std;
// Graph is represented using adjacency list. Every node
// of adjacency list contains vertex number of the vertex
// to which edge connects. It also
// contains weight of the edge
class AdjListNode
{
int v;
int weight;
public:
AdjListNode(int _v, int _w) { v = _v; weight = _w;}
int getV() { return v; }
int getWeight() { return weight; }
};
// Class to represent a graph using adjacency
// list representation
class Graph
{
int V; // No. of vertices'
// Pointer to an array containing adjacency lists
list<AdjListNode> *adj;
// A function used by shortestPath
void topologicalSortUtil(int v, bool visited[], stack<int> &Stack);
public:
Graph(int V); // Constructor
// function to add an edge to graph
void addEdge(int u, int v, int weight);
// Finds shortest paths from given source vertex
void shortestPath(int s);
};
Graph::Graph(int V)
{
this->V = V;
adj = new list<AdjListNode>[V];
}
void Graph::addEdge(int u, int v, int weight)
{
AdjListNode node(v, weight);
adj[u].push_back(node); // Add v to u's list
}
// A recursive function used by shortestPath.
// See below link for details
// https://www.geeksforgeeks.org/topological-sorting/
void Graph::topologicalSortUtil(int v, bool visited[], stack<int> &Stack)
{
// Mark the current node as visited
visited[v] = true;
// Recur for all the vertices adjacent to this vertex
list<AdjListNode>::iterator i;
for (i = adj[v].begin(); i != adj[v].end(); ++i)
{
AdjListNode node = *i;
if (!visited[node.getV()])
topologicalSortUtil(node.getV(), visited, Stack);
}
// Push current vertex to stack which stores topological sort
Stack.push(v);
}
// The function to find shortest paths from given vertex.
// It uses recursive topologicalSortUtil() to get topological
// sorting of given graph.
void Graph::shortestPath(int s)
{
stack<int> Stack;
int dist[V];
// Mark all the vertices as not visited
bool *visited = new bool[V];
for (int i = 0; i < V; i++)
visited[i] = false;
// Call the recursive helper function to store
// Topological Sort starting from all vertices
// one by one
for (int i = 0; i < V; i++)
if (visited[i] == false)
topologicalSortUtil(i, visited, Stack);
// Initialize distances to all vertices as
// infinite and distance to source as 0
for (int i = 0; i < V; i++)
dist[i] = INF;
dist[s] = 0;
// Process vertices in topological order
while (Stack.empty() == false)
{
// Get the next vertex from topological order
int u = Stack.top();
Stack.pop();
// Update distances of all adjacent vertices
list<AdjListNode>::iterator i;
if (dist[u] != INF)
{
for (i = adj[u].begin(); i != adj[u].end(); ++i)
if (dist[i->getV()] > dist[u] + i->getWeight())
dist[i->getV()] = dist[u] + i->getWeight();
}
}
// Print the calculated shortest distances
for (int i = 0; i < V; i++)
(dist[i] == INF)? cout << ""INF "": cout << dist[i] << "" "";
}
// Driver program to test above functions
int main()
{
// Create a graph given in the above diagram.
// Here vertex numbers are 0, 1, 2, 3, 4, 5 with
// following mappings: 0=r, 1=s, 2=t, 3=x, 4=y, 5=z
Graph g(6);
g.addEdge(0, 1, 5);
g.addEdge(0, 2, 3);
g.addEdge(1, 3, 6);
g.addEdge(1, 2, 2);
g.addEdge(2, 4, 4);
g.addEdge(2, 5, 2);
g.addEdge(2, 3, 7);
g.addEdge(3, 4, -1);
g.addEdge(4, 5, -2);
int s = 1;
cout << ""Following are shortest distances from source "" << s <<"" n"";
g.shortestPath(s);
return 0;
}"
31,Dial,"Below is the complete algorithm  1. Maintains some buckets, numbered 0, 1, 2, ,wV. 2. Bucket k contains all temporarily labeled nodes with a distance equal to k. 3. Nodes in each bucket are represented by a list of vertices. 4. Buckets 0, 1, 2,..wV are checked sequentially until the first non empty bucket is found. Each node contained in the first non empty bucket has the minimum distance label by definition. 5. One by one, these nodes with minimum distance labels are permanently labeled and deleted from the bucket during the scanning process. 6. Thus operations involving vertex include        Checking if a bucket is empty       Adding a vertex to a bucket       Deleting a vertex from a bucket.  7. The position of a temporarily labeled vertex in the buckets is updated accordingly when the distance label of a vertex changes. 8. The process is repeated until all vertices are permanently labeled  or the distances of all vertices are finalized .","// C++ Program for Dijkstra's dial implementation
#include<bits/stdc++.h>
using namespace std;
# define INF 0x3f3f3f3f
// This class represents a directed graph using
// adjacency list representation
class Graph
{
int V; // No. of vertices
// In a weighted graph, we need to store vertex
// and weight pair for every edge
list< pair<int, int> > adj;
public:
Graph(int V); // Constructor
// function to add an edge to graph
void addEdge(int u, int v, int w);
// prints shortest path from s
void shortestPath(int s, int W);
};
// Allocates memory for adjacency list
Graph::Graph(int V)
{
this->V = V;
adj = new list< pair<int, int> >[V];
}
// adds edge between u and v of weight w
void Graph::addEdge(int u, int v, int w)
{
adj[u].push_back(make_pair(v, w));
adj[v].push_back(make_pair(u, w));
}
// Prints shortest paths from src to all other vertices.
// W is the maximum weight of an edge
void Graph::shortestPath(int src, int W)
{
/ With each distance, iterator to that vertex in
its bucket is stored so that vertex can be deleted
in O(1) at time of updation. So
dist[i].first = distance of ith vertex from src vertex
dist[i].second = iterator to vertex i in bucket number /
vector<pair<int, list<int>::iterator> > dist(V);
// Initialize all distances as infinite (INF)
for (int i = 0; i < V; i++)
dist[i].first = INF;
// Create buckets B[].
// B[i] keep vertex of distance label i
list<int> B[W * V + 1];
B[0].push_back(src);
dist[src].first = 0;
//
int idx = 0;
while (1)
{
// Go sequentially through buckets till one non-empty
// bucket is found
while (B[idx].size() == 0 && idx < WV)
idx++;
// If all buckets are empty, we are done.
if (idx == W * V)
break;
// Take top vertex from bucket and pop it
int u = B[idx].front();
B[idx].pop_front();
// Process all adjacents of extracted vertex 'u' and
// update their distanced if required.
for (auto i = adj[u].begin(); i != adj[u].end(); ++i)
{
int v = (*i).first;
int weight = (*i).second;
int du = dist[u].first;
int dv = dist[v].first;
// If there is shorted path to v through u.
if (dv > du + weight)
{
// If dv is not INF then it must be in B[dv]
// bucket, so erase its entry using iterator
// in O(1)
if (dv != INF)
B[dv].erase(dist[v].second);
// updating the distance
dist[v].first = du + weight;
dv = dist[v].first;
// pushing vertex v into updated distance's bucket
B[dv].push_front(v);
// storing updated iterator in dist[v].second
dist[v].second = B[dv].begin();
}
}
}
// Print shortest distances stored in dist[]
printf(""Vertex Distance from Source\n"");
for (int i = 0; i < V; ++i)
printf(""%d %d\n"", i, dist[i].first);
}
// Driver program to test methods of graph class
int main()
{
// create the graph given in above figure
int V = 9;
Graph g(V);
// making above shown graph
g.addEdge(0, 1, 4);
g.addEdge(0, 7, 8);
g.addEdge(1, 2, 8);
g.addEdge(1, 7, 11);
g.addEdge(2, 3, 7);
g.addEdge(2, 8, 2);
g.addEdge(2, 5, 4);
g.addEdge(3, 4, 9);
g.addEdge(3, 5, 14);
g.addEdge(4, 5, 10);
g.addEdge(5, 6, 2);
g.addEdge(6, 7, 1);
g.addEdge(6, 8, 6);
g.addEdge(7, 8, 7);
// maximum weighted edge - 14
g.shortestPath(0, 14);
return 0;
}
// This code is contributed by Aditya Kumar (adityakumar129)"
32,Multistage graph,"A Multistage graph is a directed, weighted graph in which the nodes can be divided into a set of stages such that all edges are from a stage to next stage only  In other words there is no edge between vertices of same stage and from a vertex of current stage to previous stage .","// CPP program to find shortest distance
// in a multistage graph.
#include<bits/stdc++.h>
using namespace std;
#define N 8
#define INF INT_MAX
// Returns shortest distance from 0 to
// N-1.
int shortestDist(int graph[N][N]) {
// dist[i] is going to store shortest
// distance from node i to node N-1.
int dist[N];
dist[N-1] = 0;
// Calculating shortest path for
// rest of the nodes
for (int i = N-2 ; i >= 0 ; i--)
{
// Initialize distance from i to
// destination (N-1)
dist[i] = INF;
// Check all nodes of next stages
// to find shortest distance from
// i to N-1.
for (int j = i ; j < N ; j++)
{
// Reject if no edge exists
if (graph[i][j] == INF)
continue;
// We apply equation to
// distance to target through j.
// and compare with minimum distance
// so far.
dist[i] = min(dist[i], graph[i][j] +
dist[j]);
}
}
return dist[0];
}
// Driver code
int main()
{
// Graph stored in the form of an
// adjacency Matrix
int graph[N][N] =
{{INF, 1, 2, 5, INF, INF, INF, INF},
{INF, INF, INF, INF, 4, 11, INF, INF},
{INF, INF, INF, INF, 9, 5, 16, INF},
{INF, INF, INF, INF, INF, INF, 2, INF},
{INF, INF, INF, INF, INF, INF, INF, 18},
{INF, INF, INF, INF, INF, INF, INF, 13},
{INF, INF, INF, INF, INF, INF, INF, 2},
{INF, INF, INF, INF, INF, INF, INF, INF}};
cout << shortestDist(graph);
return 0;
}"
33,Shortest path in an unweighted graph,"Create a queue and add the starting vertex to it.  Create an array to keep track of the distances from the starting vertex to all other vertices. Initialize all distances to infinity except for the starting vertex, which should have a distance of 0.  While the queue is not empty, dequeue the next vertex.  For each neighbor of the dequeued vertex that has not been visited, set its distance to the distance of the dequeued vertex plus 1 and add it to the queue.  Repeat steps 3 4 until the queue is empty.  The distances array now contains the shortest path distances from the starting vertex to all other vertices.","// CPP code for printing shortest path between
// two vertices of unweighted graph
#include <bits/stdc++.h>
using namespace std;
// utility function to form edge between two vertices
// source and dest
void add_edge(vector<int> adj[], int src, int dest)
{
adj[src].push_back(dest);
adj[dest].push_back(src);
}
// a modified version of BFS that stores predecessor
// of each vertex in array p
// and its distance from source in array d
bool BFS(vector<int> adj[], int src, int dest, int v,
int pred[], int dist[])
{
// a queue to maintain queue of vertices whose
// adjacency list is to be scanned as per normal
// DFS algorithm
list<int> queue;
// boolean array visited[] which stores the
// information whether ith vertex is reached
// at least once in the Breadth first search
bool visited[v];
// initially all vertices are unvisited
// so v[i] for all i is false
// and as no path is yet constructed
// dist[i] for all i set to infinity
for (int i = 0; i < v; i++) {
visited[i] = false;
dist[i] = INT_MAX;
pred[i] = -1;
}
// now source is first to be visited and
// distance from source to itself should be 0
visited[src] = true;
dist[src] = 0;
queue.push_back(src);
// standard BFS algorithm
while (!queue.empty()) {
int u = queue.front();
queue.pop_front();
for (int i = 0; i < adj[u].size(); i++) {
if (visited[adj[u][i]] == false) {
visited[adj[u][i]] = true;
dist[adj[u][i]] = dist[u] + 1;
pred[adj[u][i]] = u;
queue.push_back(adj[u][i]);
// We stop BFS when we find
// destination.
if (adj[u][i] == dest)
return true;
}
}
}
return false;
}
// utility function to print the shortest distance
// between source vertex and destination vertex
void printShortestDistance(vector<int> adj[], int s,
int dest, int v)
{
// predecessor[i] array stores predecessor of
// i and distance array stores distance of i
// from s
int pred[v], dist[v];
if (BFS(adj, s, dest, v, pred, dist) == false) {
cout << ""Given source and destination""
<< "" are not connected"";
return;
}
// vector path stores the shortest path
vector<int> path;
int crawl = dest;
path.push_back(crawl);
while (pred[crawl] != -1) {
path.push_back(pred[crawl]);
crawl = pred[crawl];
}
// distance from source is in distance array
cout << ""Shortest path length is : ""
<< dist[dest];
// printing path from source to destination
cout << ""\nPath is::\n"";
for (int i = path.size() - 1; i >= 0; i--)
cout << path[i] << "" "";
}
// Driver program to test above functions
int main()
{
// no. of vertices
int v = 8;
// array of vectors is used to store the graph
// in the form of an adjacency list
vector<int> adj[v];
// Creating graph given in the above diagram.
// add_edge function takes adjacency list, source
// and destination vertex as argument and forms
// an edge between them.
add_edge(adj, 0, 1);
add_edge(adj, 0, 3);
add_edge(adj, 1, 2);
add_edge(adj, 3, 4);
add_edge(adj, 3, 7);
add_edge(adj, 4, 5);
add_edge(adj, 4, 6);
add_edge(adj, 4, 7);
add_edge(adj, 5, 6);
add_edge(adj, 6, 7);
int source = 0, dest = 7;
printShortestDistance(adj, source, dest, v);
return 0;
}"
34,Karp’s minimum mean (or average) weight cycle algorithm,"Step 2  Compute the shortest path to all other vertices on a path consisting of k edges 0    k    V where V is number of vertices. This is a simple dp problem which can be computed by the recursive solution dp k  v    min dp k  v , dp k 1  u    weight u,v  where v is the destination and the edge u,v  should belong to E Step 3  For each vertex calculate max dp n  v  dp k  v    n k  where 0  k  n 1 Step 4  The minimum of the values calculated above is the required answer.","// C++ program to find minimum average
// weight of a cycle in connected and
// directed graph.
#include<bits/stdc++.h>
using namespace std;
const int V = 4;
// a struct to represent edges
struct edge
{
int from, weight;
};
// vector to store edges
vector <edge> edges[V];
void addedge(int u,int v,int w)
{
edges[v].push_back({u, w});
}
// calculates the shortest path
void shortestpath(int dp[][V])
{
// initializing all distances as -1
for (int i=0; i<=V; i++)
for (int j=0; j<V; j++)
dp[i][j] = -1;
// shortest distance from first vertex
// to in itself consisting of 0 edges
dp[0][0] = 0;
// filling up the dp table
for (int i=1; i<=V; i++)
{
for (int j=0; j<V; j++)
{
for (int k=0; k<edges[j].size(); k++)
{
if (dp[i-1][edges[j][k].from] != -1)
{
int curr_wt = dp[i-1][edges[j][k].from] +
edges[j][k].weight;
if (dp[i][j] == -1)
dp[i][j] = curr_wt;
else
dp[i][j] = min(dp[i][j], curr_wt);
}
}
}
}
}
// Returns minimum value of average weight of a
// cycle in graph.
double minAvgWeight()
{
int dp[V+1][V];
shortestpath(dp);
// array to store the avg values
double avg[V];
for (int i=0; i<V; i++)
avg[i] = -1;
// Compute average values for all vertices using
// weights of shortest paths store in dp.
for (int i=0; i<V; i++)
{
if (dp[V][i] != -1)
{
for (int j=0; j<V; j++)
if (dp[j][i] != -1)
avg[i] = max(avg[i],
((double)dp[V][i]-dp[j][i])/(V-j));
}
}
// Find minimum value in avg[]
double result = avg[0];
for (int i=0; i<V; i++)
if (avg[i] != -1 && avg[i] < result)
result = avg[i];
return result;
}
// Driver function
int main()
{
addedge(0, 1, 1);
addedge(0, 2, 10);
addedge(1, 2, 3);
addedge(2, 3, 2);
addedge(3, 1, 0);
addedge(3, 0, 8);
cout << minAvgWeight();
return 0;
}"
35,0-1 BFS (Shortest Path in a Binary Weight Graph),"In normal BFS of a graph, all edges have equal weight but in 0 1 BFS some edges may have 0 weight and some may have 1 weight. In this, we will not use a bool array to mark visited nodes but at each step, we will check for the optimal distance condition. We use a double endedhttps   www.geeksforgeeks.org deque set 1 introduction applications to store the node. While performing BFS if an edge having weight   0 is found node is pushed at front of the double ended queue and if an edge having weight   1 is found, it is pushed to the back of the double ended queue.The approach is similar to Dijkstra that if the shortest distance to the node is relaxed by the previous node then only it will be pushed into the queue. The above idea works in all cases, when pop a vertex  like Dijkstra , it is the minimum weight vertex among the remaining vertices. If there is a 0 weight vertex adjacent to it, then this adjacent has the same distance. If there is a 1 weight adjacent, then this adjacent has maximum distance among all vertices in the dequeue  because all other vertices are either adjacent to the currently popped vertex or adjacent to previously popped vertices .","// C++ program to implement single source
// shortest path for a Binary Graph
#include<bits/stdc++.h>
using namespace std;
/* no.of vertices */
#define V 9
// a structure to represent edges
struct node
{
// two variable one denote the node
// and other the weight
int to, weight;
};
// vector to store edges
vector <node> edges[V];
// Prints shortest distance from given source to
// every other vertex
void zeroOneBFS(int src)
{
// Initialize distances from given source
int dist[V];
for (int i=0; i<V; i++)
dist[i] = INT_MAX;
// double ende queue to do BFS.
deque <int> Q;
dist[src] = 0;
Q.push_back(src);
while (!Q.empty())
{
int v = Q.front();
Q.pop_front();
for (int i=0; i<edges[v].size(); i++)
{
// checking for the optimal distance
if (dist[edges[v][i].to] > dist[v] + edges[v][i].weight)
{
dist[edges[v][i].to] = dist[v] + edges[v][i].weight;
// Put 0 weight edges to front and 1 weight
// edges to back so that vertices are processed
// in increasing order of weights.
if (edges[v][i].weight == 0)
Q.push_front(edges[v][i].to);
else
Q.push_back(edges[v][i].to);
}
}
}
// printing the shortest distances
for (int i=0; i<V; i++)
cout << dist[i] << "" "";
}
void addEdge(int u, int v, int wt)
{
edges[u].push_back({v, wt});
edges[v].push_back({u, wt});
}
// Driver function
int main()
{
addEdge(0, 1, 0);
addEdge(0, 7, 1);
addEdge(1, 7, 1);
addEdge(1, 2, 1);
addEdge(2, 3, 0);
addEdge(2, 5, 0);
addEdge(2, 8, 1);
addEdge(3, 4, 1);
addEdge(3, 5, 1);
addEdge(4, 5, 1);
addEdge(5, 6, 1);
addEdge(6, 7, 1);
addEdge(7, 8, 1);
int src = 0;//source node
zeroOneBFS(src);
return 0;
}"
36,add, Adds two integers and returns their sum. 2.,"int add(int a, int b) {
return a + b;
}"
37,even,"Returns true if the number is even, false otherwise.","bool isEven(int number) {
return number % 2 == 0;
}"
38,max,Returns the larger of two integers.,"int max(int a, int b) {
return (a > b) ? a : b;
}"
39,factorial,Recursively calculates the factorial of a number.,"int factorial(int n) {
if (n <= 1) return 1;
return n * factorial(n - 1);
}"
40,prime,Determines if a number is prime.,"bool isPrime(int n) {
if (n <= 1) return false;
for (int i = 2; i < n; i++) {
if (n % i == 0) return false;
}
return true;
}"
41,celsius,Converts Celsius to Fahrenheit,"double celsiusToFahrenheit(double celsius) {
return (celsius * 9 / 5) + 32;
}"
42,area of circle,Computes the area of a circle given its radius.,"double areaOfCircle(double radius) {
const double PI = 3.14159;
return PI * radius * radius;
}"
43,reverse string,Reverses a string and returns the new string.,"void reverseString(std::string &str) {
int n = str.length();
for (int i = 0; i < n / 2; i++) {
std::swap(str[i], str[n - i - 1]);
}
}"
44,leap year,Checks if a year is a leap year.,"bool isLeapYear(int year) {
return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}"
45,gdc,Finds the greatest common divisor of two numbers using recursion.,"int gcd(int a, int b) {
if (b == 0) return a;
return gcd(b, a % b);
}"
46,binary to decimal,converts binary to decimal.,"int binaryToDecimal(int binary) {
int decimal = 0, base = 1;
while (binary > 0) {
int last_digit = binary % 10;
binary = binary / 10;
decimal += last_digit * base;
base = base * 2;
}
return decimal;
}"
47,count digits,Counts the number of digits in an integer.,"int countDigits(int number) {
int count = 0;
while (number != 0) {
number = number / 10;
++count;
}
return count;
}"
48,fibonacci,Prints the first n numbers of the Fibonacci series.,"void fibonacci(int n) {
int a = 0, b = 1, next;
for (int i = 0; i < n; i++) {
std::cout << a << "" "";
next = a + b;
a = b;
b = next;
}
}"
49,palindrome,Checks if a number is a palindrome.,"bool isPalindrome(int number) {
int reversed = 0, original = number;
while (number != 0) {
reversed = reversed * 10 + number % 10;
number = number / 10;
}
return original == reversed;
}"
50,power,Computes the power of a number  base raised to the exp .,"int power(int base, int exp) {
int result = 1;
for ("
